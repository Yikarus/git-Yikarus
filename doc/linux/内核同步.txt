内核同步是什么。内核在运作时，可能处于几个状态，用户态，内核态 ，主要探究在内核态，进入内核态是由中断引起的，例如中断，异常，系统调用，软中断，tasklet，内核在这些情况下若是访问修改同一数据结构时，就需要同步机制以防止系统异常。（关于用户态进程资源和内核资源同步的问题，涉及到内核抢占的问题，linux中，处于内核态的进程不会被用户进程抢占，所以在内核态返回时数据结构就已经处理完毕，不涉及同步问题。内核态可以被另一个内核进程抢占需要打开内核抢占功能，在资源临界区不允许发生内核抢占，执行中断服务时也是，linux内中断时不可被抢占只可被嵌套，嵌套都在当前空间）
内核态时有些情况不需要内核同步：可延迟函数是顺序执行的，但多处理器时可能并发执行。
同步原语：
1、每CPU变量，每个CPU有各自的变量，由于不共享，自然不同步。
2、原子操作，汇编底层一条指令就能完成，或者加LOCK，锁定。
3、内存屏障，在内存屏障原语之后的汇编程序执行之前，内存屏障之前的那条指令已完成，还有加volatile优化屏障，volatile假设内存被修改，取内存中的值。
4、自旋锁，于单CPU无用。可衍生读写自旋锁。
5、信号量，类似互斥锁，与自旋锁占用则忙等不同，信号量睡眠。
6、顺序锁，类似读写自旋锁，但是写操作优先，可直接抢占读操作。
7、RCU，RCU（Read-Copy Update）是数据同步的一种方式，在当前的Linux内核中发挥着重要的作用。
RCU主要针对的数据对象是链表，目的是提高遍历读取数据的效率，为了达到目的使用RCU机制读取数据的时候不对链表进行耗时的加锁操作。这样在同一时间可以有多个线程同时读取该链表，并且允许一个线程对链表进行修改（修改的时候，需要加锁）。读操作几乎不做工作，写操作则多做，使用指针得到共享结构，复制到本地修改，加锁更改共享数据结构地址完成操作。也需要内存屏障来保证结构修改之后新指针才对其他人可见。RCU适用于需要频繁的读取数据，而相应修改数据并不多的情景，例如在文件系统中，经常需要查找定位目录，而对目录的修改相对来说并不多，这就是RCU发挥作用的最佳场景。
大内核锁早期是粗粒度的内核数据保护方法，现在使用更细更多锁来实现，大内核锁还有用，用来保护旧的代码，VFS等。以前用自旋锁实现，进入内核临界区自动禁止抢占，现在改用信号量kernel_sem，支持抢占，被抢占的进程依旧持有大内核锁，通过preempt_schedule_irq()在调度中多做事情。
