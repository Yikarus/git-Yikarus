linux内核中，进程是程序执行时的一个实例，是分配系统资源（CPU时间、内存）的实体，早期多线程应用程序多个执行流的创建、处理、调度都是在用户态进行，由于多线程仍看作一个进程，所以当一个线程阻塞造成一起阻塞，linux使用轻量级进程对多线程更好支持，使用线程组支持，一个线程组基本上是实现了多线程应用的一组轻量级进程。
每个进程都有进程描述符来描述他的状态、地址空间、占用文件、tty、信号表等，每个进程由进程描述符的进程ID唯一标识，进程有7种可能状态，TASK_RUNNING可运行，TASK_INTERRUPTIBLIE可中断睡眠，任意中断唤醒，TASK_UNINTERRUPTIBLE不可中断睡眠，等待唤醒条件例如设备探测，TASK_STOP暂停，TASK_TRACE跟踪，调试使用，EXIT_ZOMBIE僵死状态，EXIT_DEAD，僵死撤销。
PID分配原则分配已使用最大PID+1，用尽时使用释放的，系统维护一个PID位图，32位设定32767，两页就行，64位上限可到4194303，采用动态可扩展，分一页，用着，不够再给。线程组ID是线程组领头进程的PID，所以线程组的成员getpid()结果一致。
进程是动态的，进程描述符把进程描述小结构thread_info和对应内核堆栈放在动态分配的8K空间内，thread_info可与task_struct互相关联。
内核用进程链表管理进程，linux采用双向链表管理进程链表，每个都用哈西链表，方便查找，分别对PID，TGID线程组ID，PGID，SID建立四个表。进程运行结构，早期所有运行的进程都维护在一个链表中，每次对其进行优先级筛选都很费时间，linux2.6之后以空间换时间，TASK_RUNNING状态链表由一个包含进程数量，进程位图和140个有限级队列的链表头节点数组，不同队列包含不同优先级进程，查找方便。同样还有等待列表，等待列表没有那么复杂，每个等待列表有个头，由自旋锁和等待列表链头组成，自旋锁防止内核同时访问，等待描述符包括互斥标志，进程描述符指针，处理方式函数指针，双向链表体组成。当唤醒任务时，唤醒所有可中断睡眠的非互斥任务以及可能有的互斥任务。
