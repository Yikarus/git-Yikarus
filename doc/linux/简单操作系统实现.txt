linux系统启动过程，硬件配备主机，包括cpu，硬盘，内存，显卡，芯片组主板。
开机过程，主板上有个bios芯片，上面承载了bios程序，其入口地址为ffff0，
电脑开机时，cpu的cs:ip强制初始化为0xF000:0xFFF0，此处记载的程序是一个跳转指令因为此处到1M空间末尾就剩16位，跳转到了bios真正开始的地方，
开始检测内存，显卡等外设的信息，bios最后的工作是检测硬盘第一个扇区的数据，跳转至0x7c00，
这个值也有很深的历史元素，dos1.0支持32KB内存，MBR512KB，加上栈空间，算1KB，32KB-1K=0x7c00，固定在这是为了效率。
由此转入MBR，由于要进入保护模式 ，MBR中要利用bios中断检测硬盘，读取硬盘中的内核加载程序到内存中，然后转入（MBR到底只有一个扇区，干不了那么多活）。内核加载程序loader，
loader读取内存容量，构建GDTR，进入保护模式所必须，用来配合分页，实现虚拟地址，打开A20，刷新流水线，进入保护模式，构建页表，页目录表，打开分页，实现虚拟寻址，载入内核程序，将控制权转移到内核程序。
内核程序创建中断描述符表IDT，注册中断处理函数，
接下来内核要自己管理他的内存，将内存分为用户池与内核池，在内存靠前位置，设立内存池位图，供分配，
每个进程都有自己的页表和页目录，分配的时候再与物理内存对应，
内核建立全局进程表以及运行进程表，通常用链表或红黑树建立，为每一个建立的进程构建PCB结构，进程和线程通过其中标志识别，例如页表是否为NULL，
线程的调度通过定时器中断定时调度实现，
对于进程中的对内存，利用小区块链表进行分配与回收，大于1024字节的单独分配，小的以8字节为单位，分为各自大小的小区块链表。
接着是文件系统的建立，其基础为Inode，硬盘4KB为一个块，一个inode里可包括很多块，一级块二级块，三级块。
任意一个分区的开头存放了操作系统引导块，超级块，超级块描述了一个分区的信息，接着是空闲块位图，inode位图，inode数组，根目录，空闲块。
在进程中，由文件描述符表示文件，关联了inode，io位图等。
再者就是基于其上的应用了，一个最底层最简单的内核就这么多。