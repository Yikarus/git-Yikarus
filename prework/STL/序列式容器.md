# 序列式容器介绍

## 容器分类

​	数据结构是一种研究数据的特定排列模式，以利于搜寻或排序或其他特殊目的，用来实现某种特定的算法。

​	常用的容器有 array,list,tree,stack,queue,hash table,set,map,heap等，根据他们不同的排列方式分为序列式和关联式。

​	序列式容器是其中的元素都可以排序而并非已经排序。本章介绍常用的序列式容器以及其内部函数实现。由于array是C++内建类型，未经过STL封装，略过。

## Vector

​	vector和array类型数据排布方式和array相似，不同处在于array是静态空间，定义完后不可变，Vector是动态变化，可扩充，在超过当前容器的容量时，根据编译器不同，会自动分配新的空间，可能是1.5倍(vs)，2倍(gnu)或其他。

### 基本结构

```c++
template <class T, class Alloc = alloc>
    class vector {
    public:
        //vector 型别定义
        typedef T			value_type;
        typedef value_type*	pointer;
        typedef value_type*	iterator;
        typedef value_type&	reference;
        typedef	size_t		size_type;
        typedef ptrdiff_t	difference_type;//原生指针类型
    protected:
        //simple_alloc是SGI STL的空间配置器
        typedef simple_alloc<value_type,Alloc>	data_allocator;//以value_type的大小为单位送给底层分配器，方便按元素分配空间
        iterator	start;			//当前使用空间的头
        iterator	finish;			//当前使用空间的尾
        iterator	end_of_storage;	//当前可用空间的尾
    }
```

​	上面是组成Vector的基本元素，该结构仅使用3个指针控制整个空间，所以该结构所占空间大小为3个指针，在64位机器里是24B。

### 构造方法

```C++
public:
vector(){}//默认
template<class InputIteartor>
    vector(InputIterator first,InputIterator last){}//分配空间并从一个容器中复制到本空间
vector(size_type n,const T& value){fill_intialize(n,value);}
vector(vector<T> vec){}//从另一个vector拷贝
```



### 主要方法

```C++
public:
	iterator	begin(){return start;}
	iteartor	end(){return finish;}
	size_type	size()const{return size_type(end()-begin());}//类中的方法编译器处理为内联函数，不会影响效率
	size_type	capacity()const{return size_type(end_of_storage-begin());}
	bool		empty()const{return begin()==end();}
	reference	operator[](size_type n){return *(begin()+n);}
	reference	front(){return *begin();}
	reference	back(){return *(end()-1);}//end()指的是最后一个元素的后一个地址，Vector元素排布是左闭右开
	void		push_back(const T&x){
        if(finish!=end_of_storage){
            construct(finish,x);
            ++finish;
        }
        else{
            insert_aux(end(),x);//insert_aux是一个用于处理插入元素的函数，包括判断是否已满以分配新空间，以及异常处理
        }
    }
	void 		pop_back(){
        --finish;
        destroy(finish);
    }
	iterator erase(iterator first,iterator last){//删除左闭右开的内容
        iteartor i=copy(last,finish,first);//将要删除后面的元素覆盖之前的元素
        destroy(i,finish);//析构后面的元素
        finish=finish-(last-first);
        return first;
    }
	iterator erase(iterator postion){
        if(postion+1!=end())
            	copy(postion+1,finish,position);
        --finish;
        destroy(finish);
        return postion;
    }
	iterator insert(iterator postion,size_type n,const T&){...}//考虑新增元素过多的空间分配
```

### 迭代器失效

​	Vector在insert等可能发生空间重新配置的地方会发生迭代器失效，原因是原来的指针所指的空间由于空间重新配置失效了。

## List

​	List是链表，插入与删除时间是常数时间，由于链表结构，空间并不浪费，也不会产生迭代器失效。

​	List由List本身结构和List节点表示，List本身存放List头指针，STL List是双向链表，迭代器提供前移后退的功能，必须对迭代器的运算进行重载。

### List结构

```C++
template <class T>
    struct __list_node{
        typedef void* void_pointer;
        void_pointer prev;
        void_pointer next;//指针指代下一个节点位置
        T			 data;
    }
template <class T,class Alloc=alloc>
    class list{
    protected:
        typedef __list_node<T> list_type;
    public:
        typedef list_node* link_type;
    protected:
        link_type node;//指向第一个指针，可以表示整个环状双向列表
    }
```

​	看出此结构只有一个指针，但是在gnu中该结构占24B大小。***百思不得其解***

​	另一个神奇的地方，gnu中，list中list.end()中有值，保存的是整个list的长度，原本实现左闭右开的list需要最后添加一个空白的list.end()，gnu将其利用起来，使原本需要遍历list才能得到的长度在常数时间内可得。

### 常用方法

* assign() 给list赋值 
* back() 返回最后一个元素 
* begin() 返回指向第一个元素的迭代器 
* clear() 删除所有元素 
* empty() 如果list是空的则返回true 
* end() 返回末尾的迭代器 
* erase() 删除一个元素 
* front() 返回第一个元素 
* get_allocator() 返回list的配置器 
* insert() 插入一个元素到list中 
* max_size() 返回list能容纳的最大元素数量 
* merge() 合并两个list 
* pop_back() 删除最后一个元素 
* pop_front() 删除第一个元素 
* push_back() 在list的末尾添加一个元素 
* push_front() 在list的头部添加一个元素 
* rbegin() 返回指向第一个元素的逆向迭代器 
* remove() 从list删除元素 
* remove_if() 按指定条件删除元素 
* rend() 指向list末尾的逆向迭代器 
* resize() 改变list的大小 
* reverse() 把list的元素倒转 size() 返回list中的元素个数 
* sort() 给list排序 
* splice() 合并两个list 
* swap() 交换两个list 
* unique()去除重复